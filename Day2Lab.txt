Lab11 - channel 
            observe- comment defer close line and check deadlock message
            package main
            
            import (
            	"fmt"
            //	"time"
            )
            func main(){
            	ch := make(chan int)
            	go print("x", ch)
            
            	fmt.Println("waiting for some input on channel ")
            	for percent:= range ch {
            			fmt.Println(".. input received on channel ", percent)
            		}
            }
            
            func print(str string,ch chan int){
            	defer close(ch)	
            	for i:=1;i<=500;i++{
            		fmt.Print(str , " ")
            		if i % 100 == 0 {
            			fmt.Println("\n", str , " is ", i / 5 , " % done !!")
            			ch <- i/5
            		}
            	}	
            }

Lab10 - check -> no scan or sleep option in main, observe main does not wait for go routines to complete
                 for bigger number like 500, observe time slicing, go for small sleep in for loop and see predictable round robin         
            package main
            
            import (
            	"fmt"
            	"time"
            )
            
            func main(){
            	go print("x")
            	go print("-")
            	go print("o")
            	fmt.Println("Done !!")
            	//Options -  1. wait for io  2. sleep
            /*
            	i := 0
            	fmt.Println("Enter a number to continue")
            	fmt.Scanln(&i)
            */
            	time.Sleep(10 * time.Second)
            }
            
            func print(str string){
            	for i:=0;i<500;i++{
            		fmt.Print(str , " ")
            	}
            }
Lab9 -     Lab4
            accept empno as os.Args or scan (valid input -> 1 to 12)
            if resp header is 404 - show invalid empno 
            just show empname = firstname lastname 
            add results  in log files
Lab8 - http get 
            package main
            import (
            	"fmt"
            	"net/http"
            	"io"
            	"log"
            )
            func main(){
            	//
            	resp, err := http.Get("https://reqres.in/api/users/2")
            	fmt.Println(resp, "\n", err)
            	fmt.Println("Status = " , resp.Status , resp.StatusCode)
            	b, err := io.ReadAll(resp.Body)
            	if err != nil {
            		log.Fatal(err)
            	}
            	fmt.Println("body content = " , string(b))
            }
Lab7 - json 
            package main
            
            import (
            	"fmt"
            	"encoding/json"
            	"os"
            	"log"
            )
            type Emp struct {
            	Id     int `json:"empno"`
            	Name   string `json:"ename"`
            	Salary float32 `json:"salary"`
            }
            
            func main(){
            	emp:= Emp{10,"AAA",111.11}
            	barr, err := json.Marshal(emp)
            	fmt.Println("barr=", string(barr), "err = ", err)
            	data, err := os.ReadFile("emp.txt")
            	if err != nil {
            		log.Fatal(err)
            	}
            	e1 := Emp{}
            	err = json.Unmarshal(data, &e1)
            	if err != nil {
            		log.Fatal(err)
            	}
            	fmt.Println("Emp = " , e1)
            }
Lab6 - module dependency 
            Create a new folder - Demo3
            Lab1.go 
                        package main
                        
                        import (
                        	"fmt"
                        	"github.com/magiconair/properties"
                        )
                        
                        func main(){
                        	prop := properties.MustLoadFile("demo.properties", properties.UTF8)
                        	fmt.Println(prop)
                        	v, ok := prop.Get("host")
                        	fmt.Println(v, ok)
                        	v, ok = prop.Get("port")
                        	fmt.Println(v, ok)
                        }
            cmd>go run Lab1
            cmd>go mod init {modname}
                        check go.mod file created
            cmd>go mod tidy 
                        check go.sum and gopath folder where dependencies are downloaded
            cmd>go run Lab1
                        error 
            create demo.properties with host and port as keys
            cmd>go run Lab1

Lab5 - interfaces
            package main
            
            import "fmt"
            import "reflect"
            type Emp struct {
            	Id     int
            	Name   string
            	Salary float32
            }
            type tostr interface {
            	Convert() string 
            }
            func (emp Emp) Convert() string {
            	return "Convert is returning " + emp.Name
            }
            
            func main(){
            	emp := Emp{1,"AA",111}
            	fmt.Println(emp)
            	fmt.Printf("%T \n", emp)
            	fmt.Println(reflect.TypeOf(emp))
            	var myinterface tostr
            	myinterface = emp
            	fmt.Println(reflect.TypeOf(myinterface))
            	str:=myinterface.Convert()
            	fmt.Println(str)
            	emp.Convert()
            }
Lab4 - create Lab6.go 
            package main
            
            import (
            	"fmt"
            )
            
            type Emp struct {
            	Id     int
            	Name   string
            	Salary float32
            }
            type EmpMgr struct{
              empcoll []Emp 
            }
            func (mgr *EmpMgr) AddEmp(emp Emp){
              mgr.empcoll = append(mgr.empcoll, emp)
            }
            func (mgr EmpMgr) Print(){
              fmt.Println(  "Number   Id\t\t Name\t\t Salary")
              for i, v := range mgr.empcoll {
            		fmt.Println(i , "  = ", v.Id, "\t\t ", v.Name, "\t\t ", v.Salary)
            	}
            }	
            
            func (e Emp) Print() {
            	fmt.Printf("Name: %s\n", e.Name)
            	fmt.Printf("Number: %d\n", e.Id)
            	fmt.Printf("Salary: %f\n", e.Salary)
            }
            
            func (e *Emp) RaiseSalary(percentage int) {
            	e.Salary = e.Salary + e.Salary*float32(percentage)/100
            }
            
            func main() {
              empmgr := EmpMgr{}
            	e := Emp{ 100, "John",50000}
            	e.RaiseSalary(10)
              empmgr.AddEmp(e)
              empmgr.AddEmp(Emp{ 200, "Henr",70000})
              empmgr.AddEmp(Emp{ 300, "Tom",90000})
              empmgr.Print()
            }


Lab3 - receiver functions
      package main 
      import "fmt"
      type Vertex struct {
      	X int
      	Y int
      }
      //function 
      func print(v Vertex){
      	fmt.Println("print function " , v.X , v.Y )
      }
      //function 
      func shift(v *Vertex, dx int, dy int){
      	v.X += dx
      	v.Y += dy
      	fmt.Println("in shift function" , v)
      }
      
      //A method is a function with a special receiver argument
      func (v Vertex) print(){
      	fmt.Println("print method with receiver arg " , v.X , v.Y )
      }
      func (v *Vertex) shift( dx int, dy int){
      	v.X += dx
      	v.Y += dy
      	fmt.Println("in shift method " , v)
      }
      
      func main(){
      	v1 := Vertex{10,15}
      	print(v1)
      	v1.print()
      	shift(&v1, 5, 7)
      	v1.shift(5, 7)
      	print(v1)
      }

Lab2 - make and append 
      package main 
      import "fmt"
      
      func main(){
      	//sl1 := make([]int,3)
      	sl1 := []int{11,22,33}
      	fmt.Println(sl1)
      	fmt.Println(" sl1 length = " , len(sl1), " capacity = ", cap(sl1))
      	//func append(s []T, vs ...T) []T
      	sl1 = append(sl1, 44)
      	fmt.Println(sl1)
      	fmt.Println(" sl1 length = " , len(sl1), " capacity = ", cap(sl1))
      	sl1 = append(sl1, 55)
      	fmt.Println(sl1)
      	sl1 = append(sl1, 66)
      	fmt.Println(sl1)
      	fmt.Println(" sl1 length = " , len(sl1), " capacity = ", cap(sl1))
      	sl1 = append(sl1, 77)
      	fmt.Println(sl1)
      	fmt.Println(" sl1 length = " , len(sl1), " capacity = ", cap(sl1))
      
      }
Lab1 - in demo2 folder - Lab3 - slice
      package main 
      import "fmt"
      
      func main(){
      	//Array - Fixed Size 
      	primes := [6]int{2, 3, 5, 7, 11, 13}
      	fmt.Println(primes)
      	// Slice - Dynamic Size 
      	sl1 := primes[:]
      	fmt.Println(sl1)
      
      	sl2 := primes[0:2]
      	fmt.Println(sl2)
      
      	sl2 = primes[2:5]
      	sl2[0]= 999
      	fmt.Println(sl2)
      	fmt.Println("Array " , primes)
      }
