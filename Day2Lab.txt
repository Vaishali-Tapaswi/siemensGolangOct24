Lab5 - interfaces
            package main
            
            import "fmt"
            import "reflect"
            type Emp struct {
            	Id     int
            	Name   string
            	Salary float32
            }
            type tostr interface {
            	Convert() string 
            }
            func (emp Emp) Convert() string {
            	return "Convert is returning " + emp.Name
            }
            
            func main(){
            	emp := Emp{1,"AA",111}
            	fmt.Println(emp)
            	fmt.Printf("%T \n", emp)
            	fmt.Println(reflect.TypeOf(emp))
            	var myinterface tostr
            	myinterface = emp
            	fmt.Println(reflect.TypeOf(myinterface))
            	str:=myinterface.Convert()
            	fmt.Println(str)
            	emp.Convert()
            }
Lab4 - create Lab6.go 
            package main
            
            import (
            	"fmt"
            )
            
            type Emp struct {
            	Id     int
            	Name   string
            	Salary float32
            }
            type EmpMgr struct{
              empcoll []Emp 
            }
            func (mgr *EmpMgr) AddEmp(emp Emp){
              mgr.empcoll = append(mgr.empcoll, emp)
            }
            func (mgr EmpMgr) Print(){
              fmt.Println(  "Number   Id\t\t Name\t\t Salary")
              for i, v := range mgr.empcoll {
            		fmt.Println(i , "  = ", v.Id, "\t\t ", v.Name, "\t\t ", v.Salary)
            	}
            }	
            
            func (e Emp) Print() {
            	fmt.Printf("Name: %s\n", e.Name)
            	fmt.Printf("Number: %d\n", e.Id)
            	fmt.Printf("Salary: %f\n", e.Salary)
            }
            
            func (e *Emp) RaiseSalary(percentage int) {
            	e.Salary = e.Salary + e.Salary*float32(percentage)/100
            }
            
            func main() {
              empmgr := EmpMgr{}
            	e := Emp{ 100, "John",50000}
            	e.RaiseSalary(10)
              empmgr.AddEmp(e)
              empmgr.AddEmp(Emp{ 200, "Henr",70000})
              empmgr.AddEmp(Emp{ 300, "Tom",90000})
              empmgr.Print()
            }


Lab3 - receiver functions
      package main 
      import "fmt"
      type Vertex struct {
      	X int
      	Y int
      }
      //function 
      func print(v Vertex){
      	fmt.Println("print function " , v.X , v.Y )
      }
      //function 
      func shift(v *Vertex, dx int, dy int){
      	v.X += dx
      	v.Y += dy
      	fmt.Println("in shift function" , v)
      }
      
      //A method is a function with a special receiver argument
      func (v Vertex) print(){
      	fmt.Println("print method with receiver arg " , v.X , v.Y )
      }
      func (v *Vertex) shift( dx int, dy int){
      	v.X += dx
      	v.Y += dy
      	fmt.Println("in shift method " , v)
      }
      
      func main(){
      	v1 := Vertex{10,15}
      	print(v1)
      	v1.print()
      	shift(&v1, 5, 7)
      	v1.shift(5, 7)
      	print(v1)
      }

Lab2 - make and append 
      package main 
      import "fmt"
      
      func main(){
      	//sl1 := make([]int,3)
      	sl1 := []int{11,22,33}
      	fmt.Println(sl1)
      	fmt.Println(" sl1 length = " , len(sl1), " capacity = ", cap(sl1))
      	//func append(s []T, vs ...T) []T
      	sl1 = append(sl1, 44)
      	fmt.Println(sl1)
      	fmt.Println(" sl1 length = " , len(sl1), " capacity = ", cap(sl1))
      	sl1 = append(sl1, 55)
      	fmt.Println(sl1)
      	sl1 = append(sl1, 66)
      	fmt.Println(sl1)
      	fmt.Println(" sl1 length = " , len(sl1), " capacity = ", cap(sl1))
      	sl1 = append(sl1, 77)
      	fmt.Println(sl1)
      	fmt.Println(" sl1 length = " , len(sl1), " capacity = ", cap(sl1))
      
      }
Lab1 - in demo2 folder - Lab3 - slice
      package main 
      import "fmt"
      
      func main(){
      	//Array - Fixed Size 
      	primes := [6]int{2, 3, 5, 7, 11, 13}
      	fmt.Println(primes)
      	// Slice - Dynamic Size 
      	sl1 := primes[:]
      	fmt.Println(sl1)
      
      	sl2 := primes[0:2]
      	fmt.Println(sl2)
      
      	sl2 = primes[2:5]
      	sl2[0]= 999
      	fmt.Println(sl2)
      	fmt.Println("Array " , primes)
      }
