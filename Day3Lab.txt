Lab3 - create Lab3.go 
            package main
            
            import "fmt"
            
            func divide(s1, s2 string) int {
            	no1,_:=strconv.Atoi(s1)
            	no2,_:=strconv.Atoi(s2)
            	return no1/no2
            }
            //fmt.Println(divide("100","0"))
            -------------> panic -
            //fmt.Println(divide("A","10"))
            -------------> for invalid first argument - ans -> 0

            func swap(s1,s2 string)(string, string) {
            	return s2, s1;
            }
            func calc(no1, no2 int )(int, int){
            	return no1+no2, no1-no2
            }
            func main() {
            	fmt.Println("..")
            }
      create Lab3_test.go 
          package main

           import "testing"
           
           func TestCalc(t *testing.T){
           	gotsum, gotsub := calc(10,50)
           	if (gotsum != 60 ){
           		t.Errorf("calc(10,50) = %d; want 60", gotsum)
           	}
           	if (gotsub != -40){
           		t.Errorf("calc(10,50) = %d; want -40", gotsub)
           	}
           }
           	
    cmd>go test Lab3_test.go Lab3.go 
     check flags like -v -cover
    to find coverage
      go test  Lab3_test.go Lab3.go -v -cover -coverprofile out.txt
      go tool cover -html=out.txt -o out.html
      open html page

  Write test case for swap
Lab2 - create table Emp(empno numeric primary key, ename varchar(20), salary numeric)
 
        
        1. function to Get db connection 
        2. Struct -> Emp  
        	empno, ename, salary 
        3. Struct -> EmpMgr
        		receiver methods 
        			create(Emp )
        			list () ([]Emp)
        4. main method to invoke 			
Lab2 - db connection 
        create new folder demo4 
        Lab1.go 
                package main 
                import 	(
                	"database/sql"
                         _ "github.com/go-sql-driver/mysql"
                	"fmt"
                )
                
                func main(){
                
                	db, err := sql.Open("mysql", constr)
                	defer db.Close()
                	fmt.Println("Err = ", err)
                	fmt.Println("Db =", db)
                	// create table dept (deptno numeric primary key, dname varchar(20), loc varchar(20))
                	insertsql := "insert into dept values (20, 'Fin','Hyd')"
                	result, err := db.Exec(insertsql)
                	fmt.Println("Insert Err = ", err)
                	rsaff, err := result.RowsAffected() 
                	fmt.Println("result =", rsaff)
                }
        cmd> dependency mngt (go mod init modname, go mod tidy)
        cmd>go run . 


Lab1 - Demo3\Lab7.go
        create a struct bank - balance int 
       2 functions - deposit , widraw 
                  for loop 100 - increment/decrement balance by 1 
       main 
          invoke both 
          after both are done -> channels or sleep or wait io
            show balance
        Modify for Mutex
                package main
                
                import (
                	"fmt"
                	"time"
                	"sync"
                )
                
                type Bank struct {
                	balance int
                }
                
                func closech(ch chan int) {
                	if chclose == false {
                		close(ch)
                		chclose = true
                	}
                }
                
                var chclose = false
                
                func main() {
                	//ch := make(chan int)
                	var mutex sync.Mutex	
                	bnk := Bank{0}
                	ch := make(chan int)
                
                	go bnk.deposit(ch,&mutex)
                	go bnk.withdraw(ch,&mutex)
                	fmt.Println("After both the goroutines are started ", bnk.balance)
                	fmt.Println("Balance = " , <-ch)
                	fmt.Println("Balance = " , <-ch)
                
                }
                
                func (b *Bank) deposit(ch chan int, mutex *sync.Mutex) {
                	defer closech(ch)
                	for i := 1; i <= 100; i++ {
                		mutex.Lock()
                		bal := b.balance
                		bal += 1
                		time.Sleep(1 * time.Millisecond)
                		b.balance = bal
                		mutex.Unlock()
                		if i%100 == 0 {
                			fmt.Println("balanace after deposit is ", b.balance)
                		}
                	}
                	ch<- b.balance
                }
                
                func (b *Bank) withdraw(ch chan int, mutex *sync.Mutex) {
                	defer closech(ch)
                	for i := 1; i <= 100; i++ {
                		mutex.Lock()
                		bal := b.balance
                		bal -= 1
                		time.Sleep(1 * time.Millisecond)
                		b.balance = bal
                		mutex.Unlock()
                		if i%100 == 0 {
                
                			fmt.Println("balanace after withdraw is ", b.balance)
                		}
                
                	}
                	ch<- b.balance
                }
