Lab4 - Create docker image 
	create a folder tmp and two files 
		mkdir tmp
		cd tmp
		echo "" > demo.go
		echo "" > dockerfile
	click on editor to edit both the files
	demo.go 
	      package main
	      
	      import (
	      	"fmt"
	      	"log"
	      	"net/http"
	      )
	      
	      func main() {
	      	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
	      		fmt.Fprint(w, "<h1>Hello World !!</h1>")
	      	})
		fmt.Println("starting the server on 8080")
	      	log.Fatal(http.ListenAndServe(":8080", nil))
	      }
	dockerfile
		FROM golang
		COPY demo.go .
		EXPOSE 8080
		CMD ["go", "run", "./demo.go"]
	cmd in tmp>docker build . -t myimg
	create a container from myimg by mapping 8085 to 8080 and check on browser 

Lab3 - Docker 
	docker ps - list of containers
	docker images - list of images
	docker run imagename  - create a container 
	
	create a container for hello-world
		docker run hello-world	
			see messages for image not found, downloading 
		docker run hello-world	
			no download, just execution
		docker ps	
			no running container
		docker ps -a
			it will show you 2 containers
	create tomcat container with port mapping 
		docker run  -d -p 8080:8080 tomcat
		docker run  -d -p 8081:8080 tomcat
		click on open port and check 8080, 8081 (404 -> means server running)
	
Lab2 - create new folder demo6
        create new folder demo6\dblib
            create two files in dblib
                struct.go
                    package dblib
                    
                    type Emp struct {
                    	EmpNo  int     `json:"empno"`
                    	EName  string  `json:"ename"`
                    	Salary float64 `json:"salary"`
                    }
                    
                    type EmpMgr struct {
                    }
              dblib.go
                package dblib
                
                import (
                	"database/sql"
                	_ "github.com/go-sql-driver/mysql"
                )
                
                func getDBConnection() *sql.DB {
                	dsn := "admin:MyPassword@tcp(database-1.ctu244mmwtr1.us-east-1.rds.amazonaws.com:3306)/mydb"
                	db, err := sql.Open("mysql", dsn)
                	if err != nil {
                		panic("Problem in getting database connection")
                	}
                	return db
                }
                
                func (mgr *EmpMgr) Create(emp Emp) error {
                	dbConnection := getDBConnection()
                	defer dbConnection.Close()
                	query := "INSERT INTO Emp (empno, ename, salary) VALUES (?, ?, ?)"
                	_, err := dbConnection.Exec(query, emp.EmpNo, emp.EName, emp.Salary)
                	return err
                }
                
                func (mgr *EmpMgr) List() ([]Emp, error) {
                	dbConnection := getDBConnection()
                	defer dbConnection.Close()
                	query := "SELECT * FROM Emp"
                	rows, err := dbConnection.Query(query)
                	if err != nil {
                		return nil, err
                	}
                	defer rows.Close()
                	var employees []Emp
                	for rows.Next() {
                		var emp Emp
                		rows.Scan(&emp.EmpNo, &emp.EName, &emp.Salary)
                		employees = append(employees, emp)
                	}
                	return employees, nil
                }
    create file web.go in demo6 
            package main

            import (
            	"example.com/dblib"
            	"encoding/json"
            	"fmt"
            	"log"
            	"net/http"
            )
            
            func myhandlefunc(w http.ResponseWriter, r *http.Request) {
            	mgr := dblib.EmpMgr{}
            	switch method := r.Method; method {
            	case "GET":
            		if employees, err := mgr.List(); err != nil {
            			fmt.Println(err)
            		} else {
            			barr, _ := json.Marshal(employees)
            			w.Write(barr)
            		}
            	case "POST":
            		fmt.Fprint(w, "<h1>Post Method</h1>"+r.Method)
            		emp := dblib.Emp{}
            		err := json.NewDecoder(r.Body).Decode(&emp)
            		fmt.Println("err", err)
            		fmt.Println("in post ", emp)
            		if err := mgr.Create(emp); err != nil {
            			fmt.Println(err)
            		}
            		fmt.Fprint(w, "<h1>Inserted </h1>")
            	}
            }
            func main() {
            
            	http.HandleFunc("/dept", myhandlefunc)
            	log.Fatal(http.ListenAndServe(":8080", nil))
            }
    create mod files for both , go mod edit replace,

    create exe and run 
        
Lab1 - library and client to call
    create a folder demo5
    create two folders calc, client in demo5
    	1) write demo1.go demo5\calc 
          	package calc
          	import (
          		"fmt"
          	)
          
          	func Add(no1, no2 int) int {
          		fmt.Println("Calc add invoked with ", no1, no2)
          		return no1 + no2
          	}
          	func Divide(no1, no2 int) int {
          		fmt.Println("Calc divide invoked with ", no1, no2)
          		return no1 / no2
          	}
    
    	cmd\demo5\calc>go mod init tempcom/calc 
    	cmd\demo5\calc>go mod tidy 

    2) Write client.go in demo5\client
          package main
          
          import (
          	"fmt"
          	"tempcom/calc"
          )
          
          func main() {
          	no1, no2 := 100, 30
          	res := calc.Add(no1, no2)
          	fmt.Println("Result of add = ", res)
          	res = calc.Divide(no1, no2)
          	fmt.Println("Result of Divide = ", res)
          }
      cmd\demo5\client>go mod init client
      cmd\demo5\client>go mod tidy 
        run the client code and watch error 
      cmd\demo5\client>go mod edit -replace tempcom/calc=../calc 
      cmd\demo5\client>go mod tidy 
      cmd\demo5\client>go run Client

  
